<!DOCTYPE html>
<html dir="ltr" class="client-js" data-darkreader-mode="dynamic" data-darkreader-scheme="dark" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, #bit-notification-bar-iframe, ::-webkit-calendar-picker-indicator {
    filter: invert(100%) hue-rotate(180deg) contrast(90%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: #131516;
   --darkreader-neutral-text: #d8d4cf;
   --darkreader-selection-background: #004daa;
   --darkreader-selection-text: #e8e6e3;
}</style><style class="darkreader darkreader--root-vars" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #181a1b !important;
}
html, body, input, textarea, select, button {
    background-color: #181a1b;
}
html, body, input, textarea, select, button {
    border-color: #736b5e;
    color: #e8e6e3;
}
a {
    color: #3391ff;
}
table {
    border-color: #545b5e;
}
::placeholder {
    color: #b2aba1;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #555b00 !important;
    color: #e8e6e3 !important;
}
::-webkit-scrollbar {
    background-color: #202324;
    color: #aba499;
}
::-webkit-scrollbar-thumb {
    background-color: #454a4d;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #575e62;
}
::-webkit-scrollbar-thumb:active {
    background-color: #484e51;
}
::-webkit-scrollbar-corner {
    background-color: #181a1b;
}
* {
    scrollbar-color: #454a4d #202324;
}
::selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}
::-moz-selection {
    background-color: #004daa !important;
    color: #e8e6e3 !important;
}</style>
<title>PCI - OSDev Wiki</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.18.0">
<link rel="shortcut icon" href="https://wiki.osdev.org/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="https://wiki.osdev.org/opensearch_desc.php" title="OSDev Wiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.osdev.org/api.php?action=rsd">
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="https://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom">
<link rel="stylesheet" href="PCI%20-%20OSDev%20Wiki_files/load.css"><style class="darkreader darkreader--sync" media="screen"></style>
<style type="text/css" media="all">.mw-collapsible-toggle{float:right} li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}

/* cache key: wikidb:resourceloader:filter:minify-css:4:4250852ed2349a0d4d0fc6509a3e7d4c */
</style><style class="darkreader darkreader--sync" media="screen"></style><style type="text/css" media="all">.js-messagebox{margin:1em 5%;padding:0.5em 2.5%;border:1px solid #ccc;background-color:#fcfcfc;font-size:0.8em}.js-messagebox .js-messagebox-group{margin:1px;padding:0.5em 2.5%;border-bottom:1px solid #ddd}.js-messagebox .js-messagebox-group:last-child{border-bottom:thin none transparent}

/* cache key: wikidb:resourceloader:filter:minify-css:4:8b08bdc91c52a9ffba396dccfb5b473c */
</style><style class="darkreader darkreader--sync" media="screen"></style><meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="PCI%20-%20OSDev%20Wiki_files/load_002.css"><style class="darkreader darkreader--sync" media="screen"></style>
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}

/* cache key: wikidb:resourceloader:filter:minify-css:4:c88e2bcd56513749bec09a7e29cb3ffa */
</style><style class="darkreader darkreader--sync" media="screen"></style>
<script src="PCI%20-%20OSDev%20Wiki_files/load_006.php"></script><meta name="darkreader" content="f895039b3c364684949adc16477ea676"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: #7b5300 !important;
    border-color: #d8b013 !important;
    color: #f3e8c8 !important;
}
::placeholder {
    opacity: 0.5 !important;
}
a[href="https://coinmarketcap.com/"] > svg[width="94"][height="16"] > path {
    fill: var(--darkreader-neutral-text) !important;
}
#edge-translate-panel-body,
.MuiTypography-body1 {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: #0f3a48 !important;
}
embed[type="application/pdf"] { filter: invert(100%) contrast(90%); }</style><script src="PCI%20-%20OSDev%20Wiki_files/load.php"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "PCI", "wgTitle": "PCI", "wgCurRevisionId": 26754, "wgArticleId": 1485, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": ["Buses", "PCI"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script><script type="text/javascript" src="PCI%20-%20OSDev%20Wiki_files/load_004.php"></script>
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #b1b100;}
.c.source-c .kw2 {color: #000000; font-weight: bold;}
.c.source-c .kw3 {color: #000066;}
.c.source-c .kw4 {color: #993333;}
.c.source-c .co1 {color: #666666; font-style: italic;}
.c.source-c .co2 {color: #339933;}
.c.source-c .coMULTI {color: #808080; font-style: italic;}
.c.source-c .es0 {color: #000099; font-weight: bold;}
.c.source-c .es1 {color: #000099; font-weight: bold;}
.c.source-c .es2 {color: #660099; font-weight: bold;}
.c.source-c .es3 {color: #660099; font-weight: bold;}
.c.source-c .es4 {color: #660099; font-weight: bold;}
.c.source-c .es5 {color: #006699; font-weight: bold;}
.c.source-c .br0 {color: #009900;}
.c.source-c .sy0 {color: #339933;}
.c.source-c .st0 {color: #ff0000;}
.c.source-c .nu0 {color: #0000dd;}
.c.source-c .nu6 {color: #208080;}
.c.source-c .nu8 {color: #208080;}
.c.source-c .nu12 {color: #208080;}
.c.source-c .nu16 {color:#800080;}
.c.source-c .nu17 {color:#800080;}
.c.source-c .nu18 {color:#800080;}
.c.source-c .nu19 {color:#800080;}
.c.source-c .me1 {color: #202020;}
.c.source-c .me2 {color: #202020;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style><style class="darkreader darkreader--sync" media="screen"></style>
<style type="text/css">/*<![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
/*]]>*/
</style><style class="darkreader darkreader--cors" media="screen">div.mw-geshi {
  padding: 1em; 
  margin: 1em 0; 
  border: 1px dashed #2f6fab;
  background-color: #f9f9f9;
}</style><style class="darkreader darkreader--sync" media="screen"></style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-PCI action-view skin-vector">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;" class="js-messagebox"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">PCI</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
								<!-- tagline -->
				<div id="siteSub">From OSDev Wiki</div>
				<!-- /tagline -->
								<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav">
					Jump to: <a href="#mw-head">navigation</a>,
					<a href="#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodycontent -->
				<div dir="ltr" class="mw-content-ltr" lang="en"><table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a href="#" class="internal" id="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#The_PCI_Bus"><span class="tocnumber">1</span> <span class="toctext">The PCI Bus</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Configuration_Space"><span class="tocnumber">2</span> <span class="toctext">Configuration Space</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Configuration_Space_Access_Mechanism_.231"><span class="tocnumber">2.1</span> <span class="toctext">Configuration Space Access Mechanism #1</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Configuration_Space_Access_Mechanism_.232"><span class="tocnumber">2.2</span> <span class="toctext">Configuration Space Access Mechanism #2</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Memory_Mapped_PCI_Configuration_Space_Access"><span class="tocnumber">2.3</span> <span class="toctext">Memory Mapped PCI Configuration Space Access</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Detecting_Configuration_Space_Access_Mechanism.2Fs"><span class="tocnumber">2.4</span> <span class="toctext">Detecting Configuration Space Access Mechanism/s</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#PCI_Device_Structure"><span class="tocnumber">2.5</span> <span class="toctext">PCI Device Structure</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="#Common_Header_Fields"><span class="tocnumber">2.5.1</span> <span class="toctext">Common Header Fields</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Header_Type_0x0"><span class="tocnumber">2.5.2</span> <span class="toctext">Header Type 0x0</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#Header_Type_0x1_.28PCI-to-PCI_bridge.29"><span class="tocnumber">2.5.3</span> <span class="toctext">Header Type 0x1 (PCI-to-PCI bridge)</span></a>
<ul>
<li class="toclevel-4 tocsection-11"><a href="#Header_Type_Register"><span class="tocnumber">2.5.3.1</span> <span class="toctext">Header Type Register</span></a></li>
<li class="toclevel-4 tocsection-12"><a href="#BIST_Register"><span class="tocnumber">2.5.3.2</span> <span class="toctext">BIST Register</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-13"><a href="#Header_Type_0x2_.28PCI-to-CardBus_bridge.29"><span class="tocnumber">2.5.4</span> <span class="toctext">Header Type 0x2 (PCI-to-CardBus bridge)</span></a>
<ul>
<li class="toclevel-4 tocsection-14"><a href="#Command_Register"><span class="tocnumber">2.5.4.1</span> <span class="toctext">Command Register</span></a></li>
<li class="toclevel-4 tocsection-15"><a href="#Status_Register"><span class="tocnumber">2.5.4.2</span> <span class="toctext">Status Register</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Base_Address_Registers"><span class="tocnumber">2.6</span> <span class="toctext">Base Address Registers</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="#Address_and_size_of_the_BAR"><span class="tocnumber">2.6.1</span> <span class="toctext">Address and size of the BAR</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-18"><a href="#Class_Codes"><span class="tocnumber">2.7</span> <span class="toctext">Class Codes</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Enumerating_PCI_Buses"><span class="tocnumber">3</span> <span class="toctext">Enumerating PCI Buses</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#.22Brute_Force.22_Scan"><span class="tocnumber">3.1</span> <span class="toctext">"Brute Force" Scan</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Recursive_Scan"><span class="tocnumber">3.2</span> <span class="toctext">Recursive Scan</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#Recursive_Scan_With_Bus_Configuration"><span class="tocnumber">3.3</span> <span class="toctext">Recursive Scan With Bus Configuration</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Configuring_PCI-to-PCI_bridges"><span class="tocnumber">3.4</span> <span class="toctext">Configuring PCI-to-PCI bridges</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="#IRQ_Handling"><span class="tocnumber">4</span> <span class="toctext">IRQ Handling</span></a></li>
<li class="toclevel-1 tocsection-25"><a href="#Message_Signaled_Interrupts"><span class="tocnumber">5</span> <span class="toctext">Message Signaled Interrupts</span></a>
<ul>
<li class="toclevel-2 tocsection-26"><a href="#Enabling_MSI"><span class="tocnumber">5.1</span> <span class="toctext">Enabling MSI</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="#Enabling_MSI-X"><span class="tocnumber">5.2</span> <span class="toctext">Enabling MSI-X</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-28"><a href="#Multi-function_Devices"><span class="tocnumber">6</span> <span class="toctext">Multi-function Devices</span></a></li>
<li class="toclevel-1 tocsection-29"><a href="#Disclaimer"><span class="tocnumber">7</span> <span class="toctext">Disclaimer</span></a></li>
<li class="toclevel-1 tocsection-30"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-31"><a href="#See_Also"><span class="tocnumber">9</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-32"><a href="#Articles"><span class="tocnumber">9.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#External_Links"><span class="tocnumber">9.2</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table>
<h2> <span class="mw-headline" id="The_PCI_Bus"> The PCI Bus </span></h2>
<p>The PCI (<a rel="nofollow" class="external text" href="https://en.wikipedia.org/wiki/Conventional_PCI">Peripheral Component Interconnect</a>)
 bus was defined to establish a high performance and low cost local bus 
that would remain through several generations of products. By combining a
 transparent upgrade path from 132 MB/s (32-bit at 33 MHz) to 528 MB/s 
(64-bit at 66 MHz) and both 5 volt and 3.3 volt signalling environments,
 the PCI bus meets the needs of both low end desktop systems and 
high-end LAN servers. The PCI bus component and add-in card interface is
 processor independent, enabling an efficient transition to future 
processors, as well as use with multiple processor architectures. The 
disadvantage of the PCI bus is the limited number of electrical loads it
 can drive. A single PCI bus can drive a maximum of 10 loads. (Remember 
when counting the number of loads on the bus, a connector counts as one 
load and the PCI device counts as another, and sometimes two.)
</p>
<h2> <span class="mw-headline" id="Configuration_Space"> Configuration Space </span></h2>
<p>The PCI specification provides for totally software driven 
initialization and configuration of each device (or target) on the PCI 
Bus via a separate Configuration Address Space. All PCI devices, except 
host bus bridges, are required to provide 256 bytes of configuration 
registers for this purpose.
</p><p>Configuration read/write cycles are used to access the 
Configuration Space of each target device. A target is selected during a
 configuration access when its IDSEL signal is asserted. The IDSEL acts 
as the classic "chip select" signal. During the address phase of the 
configuration cycle, the processor can address one of 64 32-bit 
registers within the configuration space by placing the required 
register number on address lines 2 through 7 (AD[7..2]) and the byte 
enable lines.
</p><p>PCI devices are inherently little-endian, meaning all multiple 
byte fields have the least significant values at the lower addresses. 
This requires a big-endian processor, such as a Power PC, to perform the
 proper byte-swapping of data read from or written to the PCI device, 
including any accesses to the Configuration Address Space.
</p><p>Systems must provide a mechanism that allows access to the PCI 
configuration space, as most CPUs do not have any such mechanism. This 
task is usually performed by the Host to PCI Bridge (Host Bridge). Two 
distinct mechanisms are defined to allow the software to generate the 
required configuration accesses. Configuration mechanism #1 is the 
preferred method, while mechanism #2 is provided for backwards 
compatibility. Only configuration mechanism #1 will be described here, 
as it is the only access mechanism that will be used in the future.
</p>
<h3> <span class="mw-headline" id="Configuration_Space_Access_Mechanism_.231"> Configuration Space Access Mechanism #1 </span></h3>
<p>Two 32-bit I/O locations are used, the first location (<code>0xCF8</code>) is named CONFIG_ADDRESS, and the second (<code>0xCFC</code>)
 is called CONFIG_DATA. CONFIG_ADDRESS specifies the configuration 
address that is required to be accesses, while accesses to CONFIG_DATA 
will actually generate the configuration access and will transfer the 
data to or from the CONFIG_DATA register.
</p><p>The CONFIG_ADDRESS is a 32-bit register with the format shown in 
following figure. Bit 31 is an enable flag for determining when accesses
 to CONFIG_DATA should be translated to configuration cycles. Bits 23 
through 16 allow the configuration software to choose a specific PCI bus
 in the system. Bits 15 through 11 select the specific device on the PCI
 Bus. Bits 10 through 8 choose a specific function in a device (if the 
device supports multiple functions). 
</p><p>The least significant byte selects the offset into the 256-byte 
configuration space available through this method. Since all reads and 
writes must be both 32-bits and aligned to work on all implementations, 
the two lowest bits of CONFIG_ADDRESS must always be zero, with the 
remaining six bits allowing you to choose each of the 64 32-bit words. 
If you don't need all 32 bits, you'll have to perform the unaligned 
access in software by aligning the address, followed by masking and 
shifting the answer.
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bit 31
</th>
<th> Bits 30-24
</th>
<th> Bits 23-16
</th>
<th> Bits 15-11
</th>
<th> Bits 10-8
</th>
<th> Bits 7-0
</th></tr>
<tr>
<td> Enable Bit
</td>
<td> Reserved
</td>
<td> Bus Number
</td>
<td> Device Number
</td>
<td> Function Number
</td>
<td> Register Offset<sup>1</sup>
</td></tr></tbody></table>
<p><sup>1</sup> Register Offset has to point to consecutive DWORDs, ie. bits 1:0 are always 0b00 (they are still part of the Register Offset).
</p><p>The following code segment illustrates the use of configuration 
mechanism #1 to read 16-bit fields from configuration space. Note that 
this segment, the outl(port, value) and inl(port) functions refer to the
 OUTL and INL Pentium assembly language instructions. 
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">uint16_t</span> pciConfigReadWord<span class="br0">(</span><span class="kw4">uint8_t</span> bus<span class="sy0">,</span> <span class="kw4">uint8_t</span> slot<span class="sy0">,</span> <span class="kw4">uint8_t</span> func<span class="sy0">,</span> <span class="kw4">uint8_t</span> offset<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">uint32_t</span> address<span class="sy0">;</span>
    <span class="kw4">uint32_t</span> lbus  <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">uint32_t</span><span class="br0">)</span>bus<span class="sy0">;</span>
    <span class="kw4">uint32_t</span> lslot <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">uint32_t</span><span class="br0">)</span>slot<span class="sy0">;</span>
    <span class="kw4">uint32_t</span> lfunc <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">uint32_t</span><span class="br0">)</span>func<span class="sy0">;</span>
    <span class="kw4">uint16_t</span> tmp <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Create configuration address as per Figure 1</span>
    address <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">uint32_t</span><span class="br0">)</span><span class="br0">(</span><span class="br0">(</span>lbus <span class="sy0">&lt;&lt;</span> <span class="nu0">16</span><span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span>lslot <span class="sy0">&lt;&lt;</span> <span class="nu0">11</span><span class="br0">)</span> <span class="sy0">|</span>
              <span class="br0">(</span>lfunc <span class="sy0">&lt;&lt;</span> <span class="nu0">8</span><span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span>offset <span class="sy0">&amp;</span> <span class="nu12">0xFC</span><span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="br0">(</span><span class="kw4">uint32_t</span><span class="br0">)</span><span class="nu12">0x80000000</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Write out the address</span>
    outl<span class="br0">(</span><span class="nu12">0xCF8</span><span class="sy0">,</span> address<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Read in the data</span>
    <span class="co1">// (offset &amp; 2) * 8) = 0 will choose the first word of the 32-bit register</span>
    tmp <span class="sy0">=</span> <span class="br0">(</span><span class="kw4">uint16_t</span><span class="br0">)</span><span class="br0">(</span><span class="br0">(</span>inl<span class="br0">(</span><span class="nu12">0xCFC</span><span class="br0">)</span> <span class="sy0">&gt;&gt;</span> <span class="br0">(</span><span class="br0">(</span>offset <span class="sy0">&amp;</span> <span class="nu0">2</span><span class="br0">)</span> <span class="sy0">*</span> <span class="nu0">8</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFF</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> tmp<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>When a configuration access attempts to select a device that does not
 exist, the host bridge will complete the access without error, dropping
 all data on writes and returning all ones on reads. The following code 
segment illustrates the read of a non-existent device.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">uint16_t</span> pciCheckVendor<span class="br0">(</span><span class="kw4">uint8_t</span> bus<span class="sy0">,</span> <span class="kw4">uint8_t</span> slot<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">uint16_t</span> vendor<span class="sy0">,</span> device<span class="sy0">;</span>
    <span class="coMULTI">/* Try and read the first configuration register. Since there are no
     * vendors that == 0xFFFF, it must be a non-existent device. */</span>
    <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>vendor <span class="sy0">=</span> pciConfigReadWord<span class="br0">(</span>bus<span class="sy0">,</span> slot<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!=</span> <span class="nu12">0xFFFF</span><span class="br0">)</span> <span class="br0">{</span>
       device <span class="sy0">=</span> pciConfigReadWord<span class="br0">(</span>bus<span class="sy0">,</span> slot<span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
       . . .
    <span class="br0">}</span> <span class="kw1">return</span> <span class="br0">(</span>vendor<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<h3> <span class="mw-headline" id="Configuration_Space_Access_Mechanism_.232"> Configuration Space Access Mechanism #2 </span></h3>
<p>This configuration space access mechanism was deprecated in PCI 
version 2.0. This means it's only likely to exist on hardware from 
around 1992 (when PCI 1.0 was introduced) to 1993 (when PCI 2.0 was 
introduced), which limits it to 80486 and early Pentium motherboards.
</p><p>For access mechanism #2, the IO port at <code>0xCF8</code> is an 8-bit port and is used to enable/disable the access mechanism and set the function number. It has the following format:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bits 7-4
</th>
<th> Bits 3-1
</th>
<th> Bit 0
</th></tr>
<tr>
<td> Key (0 = access mechanism disabled, non-zero = access mechanism enabled)
</td>
<td> Function number
</td>
<td> Special cycle enabled if set
</td></tr></tbody></table>
<p>The IO port at <code>0xCFA</code> (the "Forwarding Register") is also
 an 8-bit port, and is used to set the bus number for subsequent PCI 
configuration space accesses.
</p><p>Once the access mechanism has been enabled; accesses to IO ports <code>0xC000</code> to <code>0xCFFF</code> are used to access PCI configuration space. The IO port number has the following format:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bits 15-12
</th>
<th> Bits 11-8
</th>
<th> Bits 7-2
</th>
<th> Bits 1-0
</th></tr>
<tr>
<td> Must be 1100b
</td>
<td> Device number
</td>
<td> Register index
</td>
<td> Must be zero
</td></tr></tbody></table>
<p>Note that this limits the system to 16 devices per PCI bus.
</p>
<h3> <span class="mw-headline" id="Memory_Mapped_PCI_Configuration_Space_Access"> Memory Mapped PCI Configuration Space Access </span></h3>
<p>PCI Express introduced a new way to access PCI configuration space, 
where it's simply memory mapped and no IO ports are used. This access 
mechanism is described in <a href="https://wiki.osdev.org/PCI_Express" title="PCI Express">PCI Express</a>.
</p><p>Note that systems that do provide the memory mapped access 
mechanism are also required to support PCI access mechanism #1 for 
backwards compatibility.
</p>
<h3> <span class="mw-headline" id="Detecting_Configuration_Space_Access_Mechanism.2Fs"> Detecting Configuration Space Access Mechanism/s </span></h3>
<p>In general there are 4 cases:
</p>
<ul><li> Computer doesn't support PCI (either the computer is too old, 
or your OS is being run at some time in the future after PCI has been 
superseded)
</li><li> Computer supports mechanism #2
</li><li> Computer supports mechanism #1 but doesn't support the memory mapped access mechanism
</li><li> Computer supports both mechanism #1 and the memory mapped access mechanism
</li></ul>
<p>For BIOS systems, <code>int 0x1A, AX=0xB101</code> will tell you if 
the system uses mechanism #1 or mechanism #2. If this function doesn't 
exist you can't be sure if the computer supports PCI or not. If it says 
mechanism #1 is supported you won't know if the memory mapped access 
mechanism is also supported or not.
</p><p>For UEFI systems, it's extremely safe to assume that mechanism #2
 is not supported; and you can test to see if the computer supports PCI 
or not by checking to see if the "PCI bus support" protocol exists. If 
PCI is supported, there's no easy way to determine if (e.g.) the 
computer supports mechanism #1 or not.
</p><p>For both BIOS and UEFI systems, you can check the ACPI tables to determine if the memory mapped access mechanism is supported.
</p><p>This leaves a few cases uncovered (e.g. where you don't know if 
whether mechanism #1 or #2 are supported despite trying all of the 
above). For these cases the only option left is manual probing. This 
means 2 specific tests - whether mechanism #1 is supported, and if not 
whether mechanism #2 is supported. Please note that manual probing has 
risks; in that if there is no PCI (e.g. the system only has ISA) the IO 
port accesses might cause undefined behaviour (especially on systems 
where the ISA bus ignores highest 6 bits of the IO port address, where 
accessing IO port <code>0xCF8</code> is the same as accessing IO port <code>0xF8</code>).
</p>
<h3> <span class="mw-headline" id="PCI_Device_Structure"> PCI Device Structure </span></h3>
<p>The PCI Specification defines the organization of the 256-byte 
Configuration Space registers and imposes a specific template for the 
space. Figures 2 &amp; 3 show the layout of the 256-byte Configuration 
space. All PCI compliant devices must support the Vendor ID, Device ID, 
Command and Status, Revision ID, Class Code and Header Type fields. 
Implementation of the other registers is optional, depending upon the 
devices functionality.
</p>
<h4> <span class="mw-headline" id="Common_Header_Fields"> Common Header Fields </span></h4>
<p>The following field descriptions are common to all Header Types:
</p>
<ul><li> <i>Device ID:</i> Identifies the particular device. Where valid IDs are allocated by the vendor.
</li><li> <i>Vendor ID:</i> Identifies the manufacturer of the device. Where valid IDs are allocated by PCI-SIG (the list is <a rel="nofollow" class="external text" href="https://pcisig.com/membership/member-companies">here</a>) to ensure uniqueness and <code>0xFFFF</code> is an invalid value that will be returned on read accesses to Configuration Space registers of non-existent devices.
</li><li> <i>Status:</i> A register used to record status information for PCI bus related events.
</li><li> <i>Command:</i> Provides control over a device's ability to 
generate and respond to PCI cycles. Where the only functionality 
guaranteed to be supported by all devices is, when a 0 is written to 
this register, the device is disconnected from the PCI bus for all 
accesses except Configuration Space access.
</li><li> <i>Class Code:</i> A read-only register that specifies the type of function the device performs.
</li><li> <i>Subclass:</i> A read-only register that specifies the specific function the device performs.
</li><li> <i>Prog IF(Programming Interface Byte):</i> A read-only register that specifies a register-level programming interface the device has, if it has any at all.
</li><li> <i>Revision ID:</i> Specifies a revision identifier for a particular device. Where valid IDs are allocated by the vendor.
</li><li> <i>BIST:</i> Represents that status and allows control of a devices BIST (built-in self test).
</li><li> <i>Header Type:</i> Identifies the layout of the rest of the header beginning at byte <code>0x10</code> of the header and also specifies whether or not the device has multiple functions. Where a value of <code>0x0</code> specifies a general device, a value of <code>0x1</code> specifies a PCI-to-PCI bridge, and a value of <code>0x2</code>
 specifies a CardBus bridge. If bit 7 of this register is set, the 
device has multiple functions; otherwise, it is a single function 
device.
</li><li> <i>Latency Timer:</i> Specifies the latency timer in units of PCI bus clocks.
</li><li> <i>Cache Line Size:</i> Specifies the system cache line size 
in 32-bit units. A device can limit the number of cacheline sizes it can
 support, if a unsupported value is written to this field, the device 
will behave as if a value of 0 was written.
</li></ul>
<h4> <span class="mw-headline" id="Header_Type_0x0"> Header Type 0x0 </span></h4>
<p>This table is applicable if the Header Type is <code>0x0</code>. (Figure 2)
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Register </th>
<th> Offset </th>
<th> Bits 31-24 </th>
<th> Bits 23-16 </th>
<th> Bits 15-8 </th>
<th> Bits 7-0
</th></tr>
<tr>
<td> 0x0
</td>
<td> 0x0
</td>
<td colspan="2"> Device ID
</td>
<td colspan="2"> Vendor ID
</td></tr>
<tr>
<td> 0x1
</td>
<td> 0x4
</td>
<td colspan="2"> Status
</td>
<td colspan="2"> Command
</td></tr>
<tr>
<td> 0x2
</td>
<td> 0x8
</td>
<td> Class code </td>
<td> Subclass </td>
<td> Prog IF </td>
<td> Revision ID
</td></tr>
<tr>
<td> 0x3
</td>
<td> 0xC
</td>
<td> BIST
</td>
<td> Header type
</td>
<td> Latency Timer
</td>
<td> Cache Line Size
</td></tr>
<tr>
<td> 0x4
</td>
<td> 0x10
</td>
<td colspan="4"> Base address #0 (BAR0)
</td></tr>
<tr>
<td> 0x5
</td>
<td> 0x14
</td>
<td colspan="4"> Base address #1 (BAR1)
</td></tr>
<tr>
<td> 0x6
</td>
<td> 0x18
</td>
<td colspan="4"> Base address #2 (BAR2)
</td></tr>
<tr>
<td> 0x7
</td>
<td> 0x1C
</td>
<td colspan="4"> Base address #3 (BAR3)
</td></tr>
<tr>
<td> 0x8
</td>
<td> 0x20
</td>
<td colspan="4"> Base address #4 (BAR4)
</td></tr>
<tr>
<td> 0x9
</td>
<td> 0x24
</td>
<td colspan="4"> Base address #5 (BAR5)
</td></tr>
<tr>
<td> 0xA
</td>
<td> 0x28
</td>
<td colspan="4"> Cardbus CIS Pointer
</td></tr>
<tr>
<td> 0xB
</td>
<td> 0x2C
</td>
<td colspan="2"> Subsystem ID
</td>
<td colspan="2"> Subsystem Vendor ID
</td></tr>
<tr>
<td> 0xC
</td>
<td> 0x30
</td>
<td colspan="4"> Expansion ROM base address
</td></tr>
<tr>
<td> 0xD
</td>
<td> 0x34
</td>
<td colspan="3"> Reserved
</td>
<td> Capabilities Pointer
</td></tr>
<tr>
<td> 0xE
</td>
<td> 0x38
</td>
<td colspan="4"> Reserved
</td></tr>
<tr>
<td> 0xF
</td>
<td> 0x3C
</td>
<td> Max latency </td>
<td> Min Grant </td>
<td> Interrupt PIN </td>
<td> Interrupt Line
</td></tr></tbody></table>
<p>The following field descriptions apply if the Header Type is <code>0x0</code>:
</p>
<ul><li> <i>CardBus CIS Pointer:</i> Points to the Card Information Structure and is used by devices that share silicon between CardBus and PCI.
</li></ul>
<ul><li> <i>Interrupt Line:</i> Specifies which input of the system 
interrupt controllers the device's interrupt pin is connected to and is 
implemented by any device that makes use of an interrupt pin. For the 
x86 architecture this register corresponds to the PIC IRQ numbers 0-15 
(and not I/O APIC IRQ numbers) and a value of <code>0xFF</code> defines no connection.
</li></ul>
<ul><li> <i>Interrupt Pin:</i> Specifies which interrupt pin the device uses. Where a value of <code>0x1</code> is INTA#, <code>0x2</code> is INTB#, <code>0x3</code> is INTC#, <code>0x4</code> is INTD#, and <code>0x0</code> means the device does not use an interrupt pin.
</li></ul>
<ul><li> <i>Max Latency:</i> A read-only register that specifies how often the device needs access to the PCI bus (in 1/4 microsecond units).
</li></ul>
<ul><li> <i>Min Grant:</i> A read-only register that specifies the burst
 period length, in 1/4 microsecond units, that the device needs 
(assuming a 33 MHz clock rate).
</li></ul>
<ul><li> <i>Capabilities Pointer:</i> Points (i.e. an offset into this 
function's configuration space) to a linked list of new capabilities 
implemented by the device. Used if bit 4 of the status register 
(Capabilities List bit) is set to 1. The bottom two bits are reserved 
and should be masked before the Pointer is used to access the 
Configuration Space.
</li></ul>
<h4> <span class="mw-headline" id="Header_Type_0x1_.28PCI-to-PCI_bridge.29"> Header Type 0x1 (PCI-to-PCI bridge) </span></h4>
<p>This table is applicable if the Header Type is <code>0x1</code> (PCI-to-PCI bridge) (Figure 3)
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Register </th>
<th> Offset </th>
<th> Bits 31-24 </th>
<th> Bits 23-16 </th>
<th> Bits 15-8 </th>
<th> Bits 7-0
</th></tr>
<tr>
<td> 0x0
</td>
<td> 0x0
</td>
<td colspan="2"> Device ID
</td>
<td colspan="2"> Vendor ID
</td></tr>
<tr>
<td> 0x1
</td>
<td> 0x4
</td>
<td colspan="2"> Status
</td>
<td colspan="2"> Command
</td></tr>
<tr>
<td> 0x2
</td>
<td> 0x8
</td>
<td> Class code </td>
<td> Subclass </td>
<td> Prog IF </td>
<td> Revision ID
</td></tr>
<tr>
<td> 0x3
</td>
<td> 0xC
</td>
<td> BIST
</td>
<td> Header type
</td>
<td> Latency Timer
</td>
<td> Cache Line Size
</td></tr>
<tr>
<td> 0x4
</td>
<td> 0x10
</td>
<td colspan="4"> Base address #0 (BAR0)
</td></tr>
<tr>
<td> 0x5
</td>
<td> 0x14
</td>
<td colspan="4"> Base address #1 (BAR1)
</td></tr>
<tr>
<td> 0x6
</td>
<td> 0x18
</td>
<td> Secondary Latency Timer
</td>
<td> Subordinate Bus Number
</td>
<td> Secondary Bus Number
</td>
<td> Primary Bus Number
</td></tr>
<tr>
<td> 0x7
</td>
<td> 0x1C
</td>
<td colspan="2"> Secondary Status
</td>
<td> I/O Limit
</td>
<td> I/O Base
</td></tr>
<tr>
<td> 0x8
</td>
<td> 0x20
</td>
<td colspan="2"> Memory Limit
</td>
<td colspan="2"> Memory Base
</td></tr>
<tr>
<td> 0x9
</td>
<td> 0x24
</td>
<td colspan="2"> Prefetchable Memory Limit
</td>
<td colspan="2"> Prefetchable Memory Base
</td></tr>
<tr>
<td> 0xA
</td>
<td> 0x28
</td>
<td colspan="4"> Prefetchable Base Upper 32 Bits
</td></tr>
<tr>
<td> 0xB
</td>
<td> 0x2C
</td>
<td colspan="4"> Prefetchable Limit Upper 32 Bits
</td></tr>
<tr>
<td> 0xC
</td>
<td> 0x30
</td>
<td colspan="2"> I/O Limit Upper 16 Bits
</td>
<td colspan="2"> I/O Base Upper 16 Bits
</td></tr>
<tr>
<td> 0xD
</td>
<td> 0x34
</td>
<td colspan="3"> Reserved
</td>
<td> Capability Pointer
</td></tr>
<tr>
<td> 0xE
</td>
<td> 0x38
</td>
<td colspan="4"> Expansion ROM base address
</td></tr>
<tr>
<td> 0xF
</td>
<td> 0x3C
</td>
<td colspan="2"> Bridge Control </td>
<td> Interrupt PIN </td>
<td> Interrupt Line
</td></tr></tbody></table>
<h5> <span class="mw-headline" id="Header_Type_Register"> Header Type Register </span></h5>
<p>Here is the layout of the Header Type register:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bit 7 </th>
<th> Bits 6-0
</th></tr>
<tr>
<td> MF
</td>
<td> Header Type
</td></tr></tbody></table>
<ul><li> <i>MF</i> - If MF = 1 Then this device has multiple functions.
</li><li> <i>Header Type</i> - <code>0x0</code> Standard Header - <code>0x1</code> PCI-to-PCI Bridge - <code>0x2</code> CardBus Bridge
</li></ul>
<h5> <span class="mw-headline" id="BIST_Register"> BIST Register </span></h5>
<p>Here is the layout of the BIST register:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bit 7 </th>
<th> Bit 6 </th>
<th> Bits 4-5 </th>
<th> Bits 0-3
</th></tr>
<tr>
<td> BIST Capable </td>
<td> Start BIST </td>
<td> Reserved </td>
<td> Completion Code
</td></tr></tbody></table>
<ul><li> <i>BIST Capable</i> - Will return 1 the device supports BIST.
</li><li> <i>Start BIST</i> - When set to 1 the BIST is invoked. This 
bit is reset when BIST completes. If BIST does not complete after 2 
seconds the device should be failed by system software.
</li><li> <i>Completion Code</i> - Will return 0, after BIST execution, if the test completed successfully.
</li></ul>
<h4> <span class="mw-headline" id="Header_Type_0x2_.28PCI-to-CardBus_bridge.29"> Header Type 0x2 (PCI-to-CardBus bridge) </span></h4>
<p>This table is applicable if the Header Type is <code>0x2</code> (PCI-to-CardBus bridge)
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Register </th>
<th> Offset </th>
<th> Bits 31-24 </th>
<th> Bits 23-16 </th>
<th> Bits 15-8 </th>
<th> Bits 7-0
</th></tr>
<tr>
<td> 0x0
</td>
<td> 0x0
</td>
<td colspan="2"> Device ID
</td>
<td colspan="2"> Vendor ID
</td></tr>
<tr>
<td> 0x1
</td>
<td> 0x4
</td>
<td colspan="2"> Status
</td>
<td colspan="2"> Command
</td></tr>
<tr>
<td> 0x2
</td>
<td> 0x8
</td>
<td> Class code </td>
<td> Subclass </td>
<td> Prog IF </td>
<td> Revision ID
</td></tr>
<tr>
<td> 0x3
</td>
<td> 0xC
</td>
<td> BIST
</td>
<td> Header type
</td>
<td> Latency Timer
</td>
<td> Cache Line Size
</td></tr>
<tr>
<td> 0x4
</td>
<td> 0x10
</td>
<td colspan="4"> CardBus Socket/ExCa base address
</td></tr>
<tr>
<td> 0x5
</td>
<td> 0x14
</td>
<td colspan="2"> Secondary status
</td>
<td> Reserved
</td>
<td> Offset of capabilities list
</td></tr>
<tr>
<td> 0x6
</td>
<td> 0x18
</td>
<td> CardBus latency timer
</td>
<td> Subordinate bus number
</td>
<td> CardBus bus number
</td>
<td> PCI bus number
</td></tr>
<tr>
<td> 0x7
</td>
<td> 0x1C
</td>
<td colspan="4"> Memory Base Address 0
</td></tr>
<tr>
<td> 0x8
</td>
<td> 0x20
</td>
<td colspan="4"> Memory Limit 0
</td></tr>
<tr>
<td> 0x9
</td>
<td> 0x24
</td>
<td colspan="4"> Memory Base Address 1
</td></tr>
<tr>
<td> 0xA
</td>
<td> 0x28
</td>
<td colspan="4"> Memory Limit 1
</td></tr>
<tr>
<td> 0xB
</td>
<td> 0x2C
</td>
<td colspan="4"> I/O Base Address 0
</td></tr>
<tr>
<td> 0xC
</td>
<td> 0x30
</td>
<td colspan="4"> I/O Limit 0
</td></tr>
<tr>
<td> 0xD
</td>
<td> 0x34
</td>
<td colspan="4"> I/O Base Address 1
</td></tr>
<tr>
<td> 0xE
</td>
<td> 0x38
</td>
<td colspan="4"> I/O Limit 1
</td></tr>
<tr>
<td> 0xF
</td>
<td> 0x3C
</td>
<td colspan="2"> Bridge Control
</td>
<td> Interrupt PIN
</td>
<td> Interrupt Line
</td></tr>
<tr>
<td> 0x10
</td>
<td> 0x40
</td>
<td colspan="2"> Subsystem Vendor ID
</td>
<td colspan="2"> Subsystem Device ID
</td></tr>
<tr>
<td> 0x11
</td>
<td> 0x44
</td>
<td colspan="4"> 16-bit PC Card legacy mode base address
</td></tr></tbody></table>
<h5> <span class="mw-headline" id="Command_Register"> Command Register </span></h5>
<p>Here is the layout of the Command register:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bits 11-15 </th>
<th> Bit 10 </th>
<th> Bit 9 </th>
<th> Bit 8 </th>
<th> Bit 7 </th>
<th> Bit 6 </th>
<th> Bit 5 </th>
<th> Bit 4 </th>
<th> Bit 3 </th>
<th> Bit 2 </th>
<th> Bit 1 </th>
<th> Bit 0
</th></tr>
<tr>
<td> Reserved
</td>
<td> Interrupt Disable
</td>
<td> Fast Back-to-Back Enable
</td>
<td> SERR# Enable
</td>
<td> Reserved
</td>
<td> Parity Error Response
</td>
<td> VGA Palette Snoop
</td>
<td> Memory Write and Invalidate Enable
</td>
<td> Special Cycles
</td>
<td> Bus Master
</td>
<td> Memory Space
</td>
<td> I/O Space
</td></tr></tbody></table>
<ul><li> <i>Interrupt Disable</i> - If set to 1 the assertion of the devices INTx# signal is disabled; otherwise, assertion of the signal is enabled.
</li><li> <i>Fast Back-Back Enable</i> - If set to 1 indicates a device 
is allowed to generate fast back-to-back transactions; otherwise, fast 
back-to-back transactions are only allowed to the same agent.
</li><li> <i>SERR# Enable</i> - If set to 1 the SERR# driver is enabled; otherwise, the driver is disabled.
</li><li> <i>Bit 7</i> - As of revision 3.0 of the PCI local bus 
specification this bit is hardwired to 0. In earlier versions of the 
specification this bit was used by devices and may have been hardwired 
to 0, 1, or implemented as a read/write bit.
</li><li> <i>Parity Error Response</i> - If set to 1 the device will 
take its normal action when a parity error is detected; otherwise, when 
an error is detected, the device will set bit 15 of the Status register 
(Detected Parity Error Status Bit), but will not assert the PERR# 
(Parity Error) pin and will continue operation as normal.
</li><li> <i>VGA Palette Snoop</i> - If set to 1 the device does not 
respond to palette register writes and will snoop the data; otherwise, 
the device will trate palette write accesses like all other accesses.
</li><li> <i>Memory Write and Invalidate Enable</i> - If set to 1 the 
device can generate the Memory Write and Invalidate command; otherwise, 
the Memory Write command must be used.
</li><li> <i>Special Cycles</i> - If set to 1 the device can monitor Special Cycle operations; otherwise, the device will ignore them.
</li><li> <i>Bus Master</i> - If set to 1 the device can behave as a bus master; otherwise, the device can not generate PCI accesses.
</li><li> <i>Memory Space</i> - If set to 1 the device can respond to Memory Space accesses; otherwise, the device's response is disabled.
</li><li> <i>I/O Space</i> - If set to 1 the device can respond to I/O Space accesses; otherwise, the device's response is disabled.
</li></ul>
<p>If the kernel configures the BARs of the devices, the kernel also have to enable bits 0 and 1 for it to activate.
</p>
<h5> <span class="mw-headline" id="Status_Register"> Status Register </span></h5>
<p>Here is the layout of the Status register:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bit 15 </th>
<th> Bit 14 </th>
<th> Bit 13 </th>
<th> Bit 12 </th>
<th> Bit 11 </th>
<th> Bits 9-10 </th>
<th> Bit 8 </th>
<th> Bit 7 </th>
<th> Bit 6 </th>
<th> Bit 5 </th>
<th> Bit 4 </th>
<th> Bit 3 </th>
<th> Bits 0-2
</th></tr>
<tr>
<td> Detected Parity Error
</td>
<td> Signaled System Error
</td>
<td> Received Master Abort
</td>
<td> Received Target Abort
</td>
<td> Signaled Target Abort
</td>
<td> DEVSEL Timing
</td>
<td> Master Data Parity Error
</td>
<td> Fast Back-to-Back Capable
</td>
<td> Reserved
</td>
<td> 66 MHz Capable
</td>
<td> Capabilities List
</td>
<td> Interrupt Status
</td>
<td> Reserved
</td></tr></tbody></table>
<ul><li> <i>Detected Parity Error</i> - This bit will be set to 1 whenever the device detects a parity error, even if parity error handling is disabled.
</li><li> <i>Signalled System Error</i> - This bit will be set to 1 whenever the device asserts SERR#.
</li><li> <i>Received Master Abort</i> - This bit will be set to 1, by a
 master device, whenever its transaction (except for Special Cycle 
transactions) is terminated with Master-Abort.
</li><li> <i>Received Target Abort</i> - This bit will be set to 1, by a master device, whenever its transaction is terminated with Target-Abort.
</li><li> <i>Signalled Target Abort</i> - This bit will be set to 1 whenever a target device terminates a transaction with Target-Abort.
</li><li> <i>DEVSEL Timing</i> - Read only bits that represent the 
slowest time that a device will assert DEVSEL# for any bus command 
except Configuration Space read and writes. Where a value of <code>0x0</code> represents fast timing, a value of <code>0x1</code> represents medium timing, and a value of <code>0x2</code> represents slow timing.
</li><li> <i>Master Data Parity Error</i> - This bit is only set when 
the following conditions are met. The bus agent asserted PERR# on a read
 or observed an assertion of PERR# on a write, the agent setting the bit
 acted as the bus master for the operation in which the error occurred, 
and bit 6 of the Command register (Parity Error Response bit) is set to 
1.
</li><li> <i>Fast Back-to-Back Capable</i> - If set to 1 the device can 
accept fast back-to-back transactions that are not from the same agent; 
otherwise, transactions can only be accepted from the same agent.
</li><li> <i>Bit 6</i> - As of revision 3.0 of the PCI Local Bus 
specification this bit is reserved. In revision 2.1 of the specification
 this bit was used to indicate whether or not a device supported User 
Definable Features.
</li><li> <i>66 MHz Capable</i> - If set to 1 the device is capable of running at 66 MHz; otherwise, the device runs at 33 MHz.
</li><li> <i>Capabilities List</i> - If set to 1 the device implements the pointer for a New Capabilities Linked list at offset <code>0x34</code>; otherwise, the linked list is not available.
</li><li> <i>Interrupt Status</i> - Represents the state of the device's
 INTx# signal. If set to 1 and bit 10 of the Command register (Interrupt
 Disable bit) is set to 0 the signal will be asserted; otherwise, the 
signal will be ignored.
</li></ul>
<p>Recall that the PCI devices follow little ENDIAN ordering. The lower 
addresses contain the least significant portions of the field. Software 
to manipulate this structure must take particular care that the 
endian-ordering follows the PCI devices, not the CPUs.
</p>
<h3> <span class="mw-headline" id="Base_Address_Registers"> Base Address Registers </span></h3>
<p>Base Address Registers (or BARs) can be used to hold memory addresses
 used by the device, or offsets for port addresses. Typically, memory 
address BARs need to be located in physical ram while I/O space BARs can
 reside at any memory address (even beyond physical memory). To 
distinguish between them, you can check the value of the lowest bit. The
 following tables describe the two types of BARs:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">
<caption>Memory Space BAR Layout
</caption>
<tbody><tr>
<th> Bits 31-4
</th>
<th> Bit 3
</th>
<th> Bits 2-1
</th>
<th> Bit 0
</th></tr>
<tr>
<td> 16-Byte Aligned Base Address
</td>
<td> Prefetchable
</td>
<td> Type
</td>
<td> Always 0
</td></tr></tbody></table>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">
<caption>I/O Space BAR Layout
</caption>
<tbody><tr>
<th> Bits 31-2
</th>
<th> Bit 1
</th>
<th> Bit 0
</th></tr>
<tr>
<td> 4-Byte Aligned Base Address
</td>
<td> Reserved
</td>
<td> Always 1
</td></tr></tbody></table>
<p>The Type field of the Memory Space BAR Layout specifies the size of 
the base register and where in memory it can be mapped. If it has a 
value of <code>0x0</code> then the base register is 32-bits wide and can be mapped anywhere in the 32-bit Memory Space. A value of <code>0x2</code>
 means the base register is 64-bits wide and can be mapped anywhere in 
the 64-bit Memory Space (A 64-bit base address register consumes 2 of 
the base address registers available). A value of <code>0x1</code> is 
reserved as of revision 3.0 of the PCI Local Bus Specification. In 
earlier versions it was used to support memory space below 1MB (16-bit 
wide base register that can be mapped anywhere in the 16-bit Memory 
Space).
</p><p>When a base address register is marked as Prefetchable, it means 
that the region does not have read side effects (reading from that 
memory range doesn't change any state), and it is allowed for the CPU to
 cache loads from that memory region and read it in bursts (typically 
cache line sized). Hardware is also allowed to merge repeated stores to 
the same address into one store of the latest value. If you are using 
paging and want maximum performance, you should map prefetchable MMIO 
regions as WT (write-through) instead of UC (uncacheable). On x86, frame
 buffers are the exception, they should be almost always be mapped WC 
(write-combining).
</p>
<h4> <span class="mw-headline" id="Address_and_size_of_the_BAR"> Address and size of the BAR </span></h4>
<p>When you want to retrieve the actual base address of a BAR, be sure 
to mask the lower bits. For 16-bit Memory Space BARs, you calculate <code>(BAR[x] &amp; 0xFFF0)</code>. For 32-bit Memory Space BARs, you calculate <code>(BAR[x] &amp; 0xFFFFFFF0)</code>. For 64-bit Memory Space BARs, you calculate <code>((BAR[x] &amp; 0xFFFFFFF0) + ((BAR[x + 1] &amp; 0xFFFFFFFF) &lt;&lt; 32))</code> For I/O Space BARs, you calculate <code>(BAR[x] &amp; 0xFFFFFFFC)</code>.
</p><p>To determine the amount of address space needed by a PCI device, 
you must save the original value of the BAR, write a value of all 1's to
 the register, then read it back. The amount of memory can then be 
determined by masking the information bits, performing a bitwise NOT 
('~' in C), and incrementing the value by 1. The original value of the 
BAR should then be restored. The BAR register is naturally aligned and 
as such you can only modify the bits that are set. For example, if a 
device utilizes 16 MB it will have BAR0 filled with 0xFF000000 
(0x1000000 after decoding) and you can only modify the upper 8-bits. <a rel="nofollow" class="external autonumber" href="https://web.archive.org/web/20150101180929/https://www.pcisig.com/reflector/msg05233.html">[1]</a>
</p>
<h3> <span class="mw-headline" id="Class_Codes"> Class Codes </span></h3>
<p>The Class Code, Subclass, and Prog IF registers are used to identify 
the device's type, the device's function, and the device's 
register-level programming interface, respectively.
</p><p>The following table details most of the known device types and functions:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Class Code </th>
<th> Subclass </th>
<th> Prog IF
</th></tr>
<tr>
<td rowspan="2"> 0x0 - Unclassified
</td>
<td> 0x0 - Non-VGA-Compatible Unclassified Device </td>
<td> --
</td></tr>
<tr>
<td> 0x1 - VGA-Compatible Unclassified Device </td>
<td> --
</td></tr>
<tr>
<td rowspan="22"> 0x1 - Mass Storage Controller
</td>
<td> 0x0 - SCSI Bus Controller </td>
<td> --
</td></tr>
<tr>
<td rowspan="8"> 0x1 - IDE Controller
</td>
<td> 0x0 - ISA Compatibility mode-only controller
</td></tr>
<tr>
<td> 0x5 - PCI native mode-only controller
</td></tr>
<tr>
<td> 0xA - ISA Compatibility mode controller, supports both channels switched to PCI native mode
</td></tr>
<tr>
<td> 0xF - PCI native mode controller, supports both channels switched to ISA compatibility mode
</td></tr>
<tr>
<td> 0x80 - ISA Compatibility mode-only controller, supports bus mastering
</td></tr>
<tr>
<td> 0x85 - PCI native mode-only controller, supports bus mastering
</td></tr>
<tr>
<td> 0x8A - ISA Compatibility mode controller, supports both channels switched to PCI native mode, supports bus mastering
</td></tr>
<tr>
<td> 0x8F - PCI native mode controller, supports both channels switched to ISA compatibility mode, supports bus mastering
</td></tr>
<tr>
<td> 0x2 - Floppy Disk Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x3 - IPI Bus Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x4 - RAID Controller </td>
<td> --
</td></tr>
<tr>
<td rowspan="2"> 0x5 - ATA Controller
</td>
<td> 0x20 - Single DMA
</td></tr>
<tr>
<td> 0x30 - Chained DMA
</td></tr>
<tr>
<td rowspan="3"> 0x6 - Serial ATA Controller
</td>
<td> 0x0 - Vendor Specific Interface
</td></tr>
<tr>
<td> 0x1 - AHCI 1.0
</td></tr>
<tr>
<td> 0x2 - Serial Storage Bus
</td></tr>
<tr>
<td rowspan="2"> 0x7 - Serial Attached SCSI Controller
</td>
<td> 0x0 - SAS
</td></tr>
<tr>
<td> 0x1 - Serial Storage Bus
</td></tr>
<tr>
<td rowspan="2"> 0x8 - Non-Volatile Memory Controller
</td>
<td> 0x1 - NVMHCI
</td></tr>
<tr>
<td> 0x2 - NVM Express
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="10"> 0x2 - Network Controller
</td>
<td> 0x0 - Ethernet Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x1 - Token Ring Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x2 - FDDI Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x3 - ATM Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x4 - ISDN Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x5 - WorldFip Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x6 - PICMG 2.14 Multi Computing Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x7 - Infiniband Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x8 - Fabric Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="5"> 0x3 - Display Controller
</td>
<td rowspan="2"> 0x0 - VGA Compatible Controller
</td>
<td> 0x0 - VGA Controller
</td></tr>
<tr>
<td> 0x1 - 8514-Compatible Controller
</td></tr>
<tr>
<td> 0x1 - XGA Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x2 - 3D Controller (Not VGA-Compatible) </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="5"> 0x4 - Multimedia Controller
</td>
<td> 0x0 - Multimedia Video Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x1 - Multimedia Audio Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x2 - Computer Telephony Device </td>
<td> --
</td></tr>
<tr>
<td> 0x3 - Audio Device </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="3"> 0x5 - Memory Controller
</td>
<td> 0x0 - RAM Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x1 - Flash Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="15"> 0x6 - Bridge
</td>
<td> 0x0 - Host Bridge </td>
<td> --
</td></tr>
<tr>
<td> 0x1 - ISA Bridge </td>
<td> --
</td></tr>
<tr>
<td> 0x2 - EISA Bridge </td>
<td> --
</td></tr>
<tr>
<td> 0x3 - MCA Bridge </td>
<td> --
</td></tr>
<tr>
<td rowspan="2"> 0x4 - PCI-to-PCI Bridge
</td>
<td> 0x0 - Normal Decode
</td></tr>
<tr>
<td> 0x1 - Subtractive Decode
</td></tr>
<tr>
<td> 0x5 - PCMCIA Bridge </td>
<td> --
</td></tr>
<tr>
<td> 0x6 - NuBus Bridge </td>
<td> --
</td></tr>
<tr>
<td> 0x7 - CardBus Bridge </td>
<td> --
</td></tr>
<tr>
<td rowspan="2"> 0x8 - RACEway Bridge
</td>
<td> 0x0 - Transparent Mode
</td></tr>
<tr>
<td> 0x1 - Endpoint Mode
</td></tr>
<tr>
<td rowspan="2"> 0x9 - PCI-to-PCI Bridge
</td>
<td> 0x40 - Semi-Transparent, Primary bus towards host CPU
</td></tr>
<tr>
<td> 0x80 - Semi-Transparent, Secondary bus towards host CPU
</td></tr>
<tr>
<td> 0x0A - InfiniBand-to-PCI Host Bridge </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="21"> 0x7 - Simple Communication Controller
</td>
<td rowspan="7"> 0x0 - Serial Controller
</td>
<td> 0x0 - 8250-Compatible (Generic XT)
</td></tr>
<tr>
<td> 0x1 - 16450-Compatible
</td></tr>
<tr>
<td> 0x2 - 16550-Compatible
</td></tr>
<tr>
<td> 0x3 - 16650-Compatible
</td></tr>
<tr>
<td> 0x4 - 16750-Compatible
</td></tr>
<tr>
<td> 0x5 - 16850-Compatible
</td></tr>
<tr>
<td> 0x6 - 16950-Compatible
</td></tr>
<tr>
<td rowspan="5"> 0x1 - Parallel Controller
</td>
<td> 0x0 - Standard Parallel Port
</td></tr>
<tr>
<td> 0x1 - Bi-Directional Parallel Port
</td></tr>
<tr>
<td> 0x2 - ECP 1.X Compliant Parallel Port
</td></tr>
<tr>
<td> 0x3 - IEEE 1284 Controller
</td></tr>
<tr>
<td> 0xFE - IEEE 1284 Target Device
</td></tr>
<tr>
<td> 0x2 - Multiport Serial Controller </td>
<td> --
</td></tr>
<tr>
<td rowspan="5"> 0x3 - Modem
</td>
<td> 0x0 - Generic Modem
</td></tr>
<tr>
<td> 0x1 - Hayes 16450-Compatible Interface
</td></tr>
<tr>
<td> 0x2 - Hayes 16550-Compatible Interface
</td></tr>
<tr>
<td> 0x3 - Hayes 16650-Compatible Interface
</td></tr>
<tr>
<td> 0x4 - Hayes 16750-Compatible Interface
</td></tr>
<tr>
<td> 0x4 - IEEE 488.1/2 (GPIB) Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x5 - Smart Card Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="18"> 0x8 - Base System Peripheral
</td>
<td rowspan="5"> 0x0 - PIC
</td>
<td> 0x0 - Generic 8259-Compatible
</td></tr>
<tr>
<td> 0x1 - ISA-Compatible
</td></tr>
<tr>
<td> 0x2 - EISA-Compatible
</td></tr>
<tr>
<td> 0x10 - I/O APIC Interrupt Controller
</td></tr>
<tr>
<td> 0x20 - I/O(x) APIC Interrupt Controller
</td></tr>
<tr>
<td rowspan="3"> 0x01 - DMA Controller
</td>
<td> 0x00 - Generic 8237-Compatible
</td></tr>
<tr>
<td> 0x01 - ISA-Compatible
</td></tr>
<tr>
<td> 0x02 - EISA-Compatible
</td></tr>
<tr>
<td rowspan="4"> 0x02 - Timer
</td>
<td> 0x00 - Generic 8254-Compatible
</td></tr>
<tr>
<td> 0x01 - ISA-Compatible
</td></tr>
<tr>
<td> 0x02 - EISA-Compatible
</td></tr>
<tr>
<td> 0x03 - HPET
</td></tr>
<tr>
<td rowspan="2"> 0x3 - RTC Controller
</td>
<td> 0x0 - Generic RTC
</td></tr>
<tr>
<td> 0x1 - ISA-Compatible
</td></tr>
<tr>
<td> 0x4 - PCI Hot-Plug Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x5 - SD Host controller </td>
<td> --
</td></tr>
<tr>
<td> 0x6 - IOMMU </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="7"> 0x9 - Input Device Controller
</td>
<td> 0x0 - Keyboard Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x1 - Digitizer Pen </td>
<td> --
</td></tr>
<tr>
<td> 0x2 - Mouse Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x3 - Scanner Controller </td>
<td> --
</td></tr>
<tr>
<td rowspan="2"> 0x4 - Gameport Controller
</td>
<td> 0x0 - Generic
</td></tr>
<tr>
<td> 0x10 - Extended
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="2"> 0xA - Docking Station
</td>
<td> 0x0 - Generic </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="9"> 0xB - Processor
</td>
<td> 0x0 - 386 </td>
<td> --
</td></tr>
<tr>
<td> 0x1 - 486 </td>
<td> --
</td></tr>
<tr>
<td> 0x2 - Pentium </td>
<td> --
</td></tr>
<tr>
<td> 0x3 - Pentium Pro </td>
<td> --
</td></tr>
<tr>
<td> 0x10 - Alpha </td>
<td> --
</td></tr>
<tr>
<td> 0x20 - PowerPC </td>
<td> --
</td></tr>
<tr>
<td> 0x30 - MIPS </td>
<td> --
</td></tr>
<tr>
<td> 0x40 - Co-Processor </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="19"> 0xC - Serial Bus Controller
</td>
<td rowspan="2"> 0x0 - FireWire (IEEE 1394) Controller
</td>
<td> 0x0 - Generic
</td></tr>
<tr>
<td> 0x10 - OHCI
</td></tr>
<tr>
<td> 0x1 - ACCESS Bus Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x2 - SSA </td>
<td> --
</td></tr>
<tr>
<td rowspan="6"> 0x3 - USB Controller
</td>
<td> 0x0 - UHCI Controller
</td></tr>
<tr>
<td> 0x10 - OHCI Controller
</td></tr>
<tr>
<td> 0x20 - EHCI (USB2) Controller
</td></tr>
<tr>
<td> 0x30 - XHCI (USB3) Controller
</td></tr>
<tr>
<td> 0x80 - Unspecified
</td></tr>
<tr>
<td> 0xFE - USB Device (Not a host controller)
</td></tr>
<tr>
<td> 0x4 - Fibre Channel </td>
<td> --
</td></tr>
<tr>
<td> 0x5 - SMBus Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x6 - InfiniBand Controller </td>
<td> --
</td></tr>
<tr>
<td rowspan="3"> 0x7 - IPMI Interface
</td>
<td> 0x0 - SMIC
</td></tr>
<tr>
<td> 0x1 - Keyboard Controller Style
</td></tr>
<tr>
<td> 0x2 - Block Transfer
</td></tr>
<tr>
<td> 0x8 - SERCOS Interface (IEC 61491) </td>
<td> --
</td></tr>
<tr>
<td> 0x9 - CANbus Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="8"> 0xD - Wireless Controller
</td>
<td> 0x0 - iRDA Compatible Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x1 - Consumer IR Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x10 - RF Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x11 - Bluetooth Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x12 - Broadband Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x20 - Ethernet Controller (802.1a) </td>
<td> --
</td></tr>
<tr>
<td> 0x21 - Ethernet Controller (802.1b) </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td> 0xE - Intelligent Controller </td>
<td> 0x0 - I20 </td>
<td> --
</td></tr>
<tr>
<td rowspan="4"> 0xF - Satellite Communication Controller
</td>
<td> 0x1 - Satellite TV Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x2 - Satellite Audio Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x3 - Satellite Voice Controller </td>
<td> --
</td></tr>
<tr>
<td> 0x4 - Satellite Data Controller </td>
<td> --
</td></tr>
<tr>
<td rowspan="3"> 0x10 - Encryption Controller
</td>
<td> 0x0 - Network and Computing Encrpytion/Decryption </td>
<td> --
</td></tr>
<tr>
<td> 0x10 - Entertainment Encryption/Decryption </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td rowspan="5"> 0x11 - Signal Processing Controller
</td>
<td> 0x0 - DPIO Modules </td>
<td> --
</td></tr>
<tr>
<td> 0x1 - Performance Counters </td>
<td> --
</td></tr>
<tr>
<td> 0x10 - Communication Synchronizer </td>
<td> --
</td></tr>
<tr>
<td> 0x20 - Signal Processing Management </td>
<td> --
</td></tr>
<tr>
<td> 0x80 - Other </td>
<td> --
</td></tr>
<tr>
<td> 0x12 - Processing Accelerator </td>
<td> -- </td>
<td> --
</td></tr>
<tr>
<td> 0x13 - Non-Essential Instrumentation </td>
<td> -- </td>
<td> --
</td></tr>
<tr>
<td> 0x14 - 0x3F (Reserved) </td>
<td> -- </td>
<td> --
</td></tr>
<tr>
<td> 0x40 - Co-Processor </td>
<td> -- </td>
<td> --
</td></tr>
<tr>
<td> 0x41 - 0xFE (Reserved) </td>
<td> -- </td>
<td> --
</td></tr>
<tr>
<td> 0xFF - Unassigned Class (Vendor specific) </td>
<td> -- </td>
<td> --
</td></tr>
</tbody></table>
<h2> <span class="mw-headline" id="Enumerating_PCI_Buses"> Enumerating PCI Buses </span></h2>
<p>There are 3 ways to enumerate devices on PCI buses. The first way is 
"brute force", checking every device on every PCI bus (regardless of 
whether the PCI bus exists or not). The second way avoids a lot of work 
by figuring out valid bus numbers while it scans, and is a little more 
complex as it involves recursion. For both of these methods you rely on 
something (firmware) to have configured PCI buses properly (setting up 
PCI to PCI bridges to forward request from one bus to another). The 
third method is like the second method, except that you configure PCI 
bridges while you're doing it.
</p><p>For all 3 methods, you need to be able to check if a specific 
device on a specific bus is present and if it is multi-function or not. 
Pseudo-code might look like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> checkDevice<span class="br0">(</span><span class="kw4">uint8_t</span> bus<span class="sy0">,</span> <span class="kw4">uint8_t</span> device<span class="br0">)</span> <span class="br0">{</span>
     <span class="kw4">uint8_t</span> <span class="kw2">function</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
&nbsp;
     vendorID <span class="sy0">=</span> getVendorID<span class="br0">(</span>bus<span class="sy0">,</span> device<span class="sy0">,</span> <span class="kw2">function</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span> <span class="br0">(</span>vendorID <span class="sy0">==</span> <span class="nu12">0xFFFF</span><span class="br0">)</span> <span class="kw1">return</span><span class="sy0">;</span> <span class="co1">// Device doesn't exist</span>
     checkFunction<span class="br0">(</span>bus<span class="sy0">,</span> device<span class="sy0">,</span> <span class="kw2">function</span><span class="br0">)</span><span class="sy0">;</span>
     headerType <span class="sy0">=</span> getHeaderType<span class="br0">(</span>bus<span class="sy0">,</span> device<span class="sy0">,</span> <span class="kw2">function</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span><span class="br0">(</span> <span class="br0">(</span>headerType <span class="sy0">&amp;</span> <span class="nu12">0x80</span><span class="br0">)</span> <span class="sy0">!=</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
         <span class="co1">// It's a multi-function device, so check remaining functions</span>
         <span class="kw1">for</span> <span class="br0">(</span><span class="kw2">function</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span> <span class="kw2">function</span> <span class="sy0">&lt;</span> <span class="nu0">8</span><span class="sy0">;</span> <span class="kw2">function</span><span class="sy0">++</span><span class="br0">)</span> <span class="br0">{</span>
             <span class="kw1">if</span> <span class="br0">(</span>getVendorID<span class="br0">(</span>bus<span class="sy0">,</span> device<span class="sy0">,</span> <span class="kw2">function</span><span class="br0">)</span> <span class="sy0">!=</span> <span class="nu12">0xFFFF</span><span class="br0">)</span> <span class="br0">{</span>
                 checkFunction<span class="br0">(</span>bus<span class="sy0">,</span> device<span class="sy0">,</span> <span class="kw2">function</span><span class="br0">)</span><span class="sy0">;</span>
             <span class="br0">}</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
 <span class="br0">}</span>
&nbsp;
 <span class="kw4">void</span> checkFunction<span class="br0">(</span><span class="kw4">uint8_t</span> bus<span class="sy0">,</span> <span class="kw4">uint8_t</span> device<span class="sy0">,</span> <span class="kw4">uint8_t</span> <span class="kw2">function</span><span class="br0">)</span> <span class="br0">{</span>
 <span class="br0">}</span></pre></div></div>
<p>Please note that if you don't check bit 7 of the header type and scan
 all functions, then some single-function devices will report details 
for "function 0" for every function.
</p>
<h3> <span class="mw-headline" id=".22Brute_Force.22_Scan"> "Brute Force" Scan </span></h3>
<p>For the brute force method, the remaining code is relatively simple. Pseudo-code might look like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> checkAllBuses<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>
     <span class="kw4">uint16_t</span> bus<span class="sy0">;</span>
     <span class="kw4">uint8_t</span> device<span class="sy0">;</span>
&nbsp;
     <span class="kw1">for</span> <span class="br0">(</span>bus <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> bus <span class="sy0">&lt;</span> <span class="nu0">256</span><span class="sy0">;</span> bus<span class="sy0">++</span><span class="br0">)</span> <span class="br0">{</span>
         <span class="kw1">for</span> <span class="br0">(</span>device <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> device <span class="sy0">&lt;</span> <span class="nu0">32</span><span class="sy0">;</span> device<span class="sy0">++</span><span class="br0">)</span> <span class="br0">{</span>
             checkDevice<span class="br0">(</span>bus<span class="sy0">,</span> device<span class="br0">)</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
 <span class="br0">}</span></pre></div></div>
<p>For this method, there are 32 devices per bus and 256 buses, so you call "checkDevice()" 8192 times.
</p>
<h3> <span class="mw-headline" id="Recursive_Scan"> Recursive Scan </span></h3>
<p>The first step for the recursive scan is to implement a function that scans one bus. Pseudo-code might look like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> checkBus<span class="br0">(</span><span class="kw4">uint8_t</span> bus<span class="br0">)</span> <span class="br0">{</span>
     <span class="kw4">uint8_t</span> device<span class="sy0">;</span>
&nbsp;
     <span class="kw1">for</span> <span class="br0">(</span>device <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> device <span class="sy0">&lt;</span> <span class="nu0">32</span><span class="sy0">;</span> device<span class="sy0">++</span><span class="br0">)</span> <span class="br0">{</span>
         checkDevice<span class="br0">(</span>bus<span class="sy0">,</span> device<span class="br0">)</span><span class="sy0">;</span>
     <span class="br0">}</span>
 <span class="br0">}</span></pre></div></div>
<p>The next step is to add code in "checkFunction()" that detects if the
 function is a PCI to PCI bridge. If the device is a PCI to PCI bridge 
then you want to extract the "secondary bus number" from the bridge's 
configuration space and call "checkBus()" with the number of the bus on 
the other side of the bridge.
</p><p>Pseudo-code might look like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> checkFunction<span class="br0">(</span><span class="kw4">uint8_t</span> bus<span class="sy0">,</span> <span class="kw4">uint8_t</span> device<span class="sy0">,</span> <span class="kw4">uint8_t</span> <span class="kw2">function</span><span class="br0">)</span> <span class="br0">{</span>
     <span class="kw4">uint8_t</span> baseClass<span class="sy0">;</span>
     <span class="kw4">uint8_t</span> subClass<span class="sy0">;</span>
     <span class="kw4">uint8_t</span> secondaryBus<span class="sy0">;</span>
&nbsp;
     baseClass <span class="sy0">=</span> getBaseClass<span class="br0">(</span>bus<span class="sy0">,</span> device<span class="sy0">,</span> <span class="kw2">function</span><span class="br0">)</span><span class="sy0">;</span>
     subClass <span class="sy0">=</span> getSubClass<span class="br0">(</span>bus<span class="sy0">,</span> device<span class="sy0">,</span> <span class="kw2">function</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>baseClass <span class="sy0">==</span> <span class="nu12">0x6</span><span class="br0">)</span> <span class="sy0">&amp;&amp;</span> <span class="br0">(</span>subClass <span class="sy0">==</span> <span class="nu12">0x4</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
         secondaryBus <span class="sy0">=</span> getSecondaryBus<span class="br0">(</span>bus<span class="sy0">,</span> device<span class="sy0">,</span> <span class="kw2">function</span><span class="br0">)</span><span class="sy0">;</span>
         checkBus<span class="br0">(</span>secondaryBus<span class="br0">)</span><span class="sy0">;</span>
     <span class="br0">}</span>
 <span class="br0">}</span></pre></div></div>
<p>The final step is to handle systems with multiple PCI host 
controllers correctly. Start by checking if the device at bus 0, device 0
 is a multi-function device. If it's not a multi-function device, then 
there is only one PCI host controller and bus 0, device 0, function 0 
will be the PCI host controller responsible for bus 0. If it's a 
multi-function device, then bus 0, device 0, function 0 will be the PCI 
host controller responsible for bus 0; bus 0, device 0, function 1 will 
be the PCI host controller responsible for bus 1, etc (up to the number 
of functions supported).
</p><p>Pseudo-code might look like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"> <span class="kw4">void</span> checkAllBuses<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>
     <span class="kw4">uint8_t</span> <span class="kw2">function</span><span class="sy0">;</span>
     <span class="kw4">uint8_t</span> bus<span class="sy0">;</span>
&nbsp;
     headerType <span class="sy0">=</span> getHeaderType<span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>headerType <span class="sy0">&amp;</span> <span class="nu12">0x80</span><span class="br0">)</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
         <span class="co1">// Single PCI host controller</span>
         checkBus<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
         <span class="co1">// Multiple PCI host controllers</span>
         <span class="kw1">for</span> <span class="br0">(</span><span class="kw2">function</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="kw2">function</span> <span class="sy0">&lt;</span> <span class="nu0">8</span><span class="sy0">;</span> <span class="kw2">function</span><span class="sy0">++</span><span class="br0">)</span> <span class="br0">{</span>
             <span class="kw1">if</span> <span class="br0">(</span>getVendorID<span class="br0">(</span><span class="nu0">0</span><span class="sy0">,</span> <span class="nu0">0</span><span class="sy0">,</span> <span class="kw2">function</span><span class="br0">)</span> <span class="sy0">!=</span> <span class="nu12">0xFFFF</span><span class="br0">)</span> <span class="kw2">break</span><span class="sy0">;</span>
             bus <span class="sy0">=</span> <span class="kw2">function</span><span class="sy0">;</span>
             checkBus<span class="br0">(</span>bus<span class="br0">)</span><span class="sy0">;</span>
         <span class="br0">}</span>
     <span class="br0">}</span>
 <span class="br0">}</span></pre></div></div>
<h3> <span class="mw-headline" id="Recursive_Scan_With_Bus_Configuration"> Recursive Scan With Bus Configuration </span></h3>
<p>This is similar to the recursive scan above; except that you set the 
"secondary bus" field in PCI to PCI bridges (using something like <code>setSecondaryBus(bus, device, function, nextBusNumber++);</code> instead of the <code>getSecondaryBus();</code>).
 However; if you are configuring PCI buses you are also responsible for 
configuring the memory areas/BARs in PCI functions, and ensuring that 
PCI bridges forward requests from their primary bus to their secondary 
buses.
</p><p>Writing code to support this without a deep understanding of PCI 
specifications is not recommended; and if you have a deep understanding 
of PCI specifications you have no need for pseudo code. For this reason 
there will be no example code for this method here.
</p>
<h3> <span class="mw-headline" id="Configuring_PCI-to-PCI_bridges"> Configuring PCI-to-PCI bridges </span></h3>
<p>To configure this the kernel has to forget about BIOS for a moment, 
first scan the root PCI device, (check if it is multi-function to scan 
multiple buses). Root bus is always 0.
</p><p>Secondary and subordinate bus acts as a range start-end of what buses the PCI-to-PCI bridge will manage.
</p><p>Then, after this step it's up to implementation: Scan each 
device, then if a bridge is found, allocate a bus number to it (note: 
PCI-to-PCI bridges can have multiple bridges within them). Scan that bus
 and find more devices, once you find more bridges add 1 to the 
subordinate bus for each bridge found, because PCI-to-PCI bridges can 
manage multiple bridges.
</p><p>And this is just the beginning: After allocating bus numbers, you
 need to allocate MMIO, it would be trivial if it wasn't for the fact 
that PCI has 3 areas the kernel manages: IO, Prefetch and Memory.
</p><p>A bridge can manage multiple buses, but that means it spans all 
the memory of these buses, if device 1 is behind bridge 2, which is 
behind bridge 1, then bridge 2 will contain the memory area of device 1 +
 any other device's areas, supposing IO is 4M, Memory is 16M and 
Prefetch is 5MB (supposing there are 3 devices in bridge's 2 bus), 
bridge 2 would contain those, take in reference table for Header type <code>0x1</code>. However, bridge 1 will contain the areas of bridge 2 + any other devices in bridge's 1 bus.
</p><p>Once all memory areas are allocated, the devices can be used. Note that PCI-to-PCI bridges also have BAR's.
</p><p>If the kernel does not configure a PCI-to-PCI bridge, the BIOS 
will probably do, however on environments without BIOS, this method is 
mandatory otherwise devices behind that bridge won't show up.
</p>
<h2> <span class="mw-headline" id="IRQ_Handling"> IRQ Handling </span></h2>
<p>If you're using the old <a href="https://wiki.osdev.org/PIC" title="PIC" class="mw-redirect">PIC</a>, your life is really easy. You have the <i>Interrupt Line</i>
 field of the header, which is read/write (you can change it's value!) 
and it says which interrupt will the PCI device fire when it needs 
attention.
</p><p>If you plan to use the <a href="https://wiki.osdev.org/I/O_APIC" title="I/O APIC" class="mw-redirect">I/O APIC</a>,
 your life will be a nightmare. You have 4 new IRQs called INTA#, INTB#,
 INTC# and INTD#. You can find which IRQ the device will use in the <i>Interrupt Line</i> field. In the ACPI AML Tables you will find (using <a href="https://wiki.osdev.org/ACPICA" title="ACPICA">ACPICA</a>) that INTA# is connected to a specified interrupt line, INTB# to another, etc...
</p><p>So far so good. You have, say, 20 devices. 10 of those are using 
INTA#, 5 for INTB#, 5 for INTC#, and none for INTD#. So when the IRQ 
number related to #INTC you have to scan the 5 devices to understand who
 was the interested one. So there is a LOT of IRQ sharing, expecially 
for INTA#.
</p><p>With time manufacturers started to use mainly INTA#, forgetting 
the existence of other pins. So you will likely have 18 devices on INTA#
 and 2 on INTB#. Motherboard manufacturers decided take the situation in
 control. So at boot the INTx# are remapped, so that you will have 5 
devices for INTA#, 5 for INTB#, 5 for INTC#, and 5 for INTD# (in the 
best case). That's great! IRQs are balanced and IRQ sharing is reduced. 
The only problem is that you don't know what devices where mapped. If 
you read the <i>Interrupt Pin</i> you still get INTA#. You now need to parse the MP Tables or the <a href="https://wiki.osdev.org/ACPI" title="ACPI">ACPI</a> ones to solve the mess. Good luck.
</p><p>Alternatively, you could just use MSI or MSI-X, and skip all that nasty ACPI stuff.
</p>
<h2> <span class="mw-headline" id="Message_Signaled_Interrupts"> Message Signaled Interrupts </span></h2>
<p>Message Signaled Interrupts, or MSI, have been supported since PCI 2.2. However, support for them is <i>mandatory</i> in PCIe devices, so you can be sure that they're usable on modern hardware.
</p><p>Use of MSI and MSI-X are mutually exclusive.
</p>
<h3> <span class="mw-headline" id="Enabling_MSI"> Enabling MSI </span></h3>
<p>First, check that the device has a pointer to the capabilities list (status register bit 4 set to 1).
Then, traverse the capabilities list. The low 8 bits of a capability register are the ID - <code>0x5</code> for MSI. The next 8 bits are the offset (in <a href="#Configuration_Space">PCI Configuration Space</a>) of the next capability.
</p><p>The MSI capability is as follows:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Register </th>
<th> Offset </th>
<th> Bits 31-24 </th>
<th> Bits 23-16 </th>
<th> Bits 15-8 </th>
<th> Bits 7-0
</th></tr>
<tr>
<td> Cap + 0x0
</td>
<td> Cap + 0x0
</td>
<td colspan="2"> Message Control
</td>
<td> Next pointer </td>
<td> Capability ID = 05
</td></tr>
<tr>
<td> Cap + 0x1
</td>
<td> Cap + 0x4
</td>
<td colspan="4"> Message Address [Low]
</td></tr>
<tr>
<td> Cap + 0x2
</td>
<td> Cap + 0x8
</td>
<td colspan="4"> [Message Address High]
</td></tr>
<tr>
<td> Cap + 0x2/0x3
</td>
<td> Cap + 0x8/0xC
</td>
<td colspan="2"> Reserved
</td>
<td colspan="2"> Message Data
</td></tr>
<tr>
<td> Cap + 0x4
</td>
<td> Cap + 0x10
</td>
<td colspan="4"> [Mask]
</td></tr>
<tr>
<td> Cap + 0x5
</td>
<td> Cap + 0x14
</td>
<td colspan="4"> [Pending]
</td></tr></tbody></table>
<p>Here is the layout of the message control register:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bits 15-9 </th>
<th> Bit 8 </th>
<th> Bit 7 </th>
<th> Bits 6-4 </th>
<th> Bits 3-1 </th>
<th> Bit 0
</th></tr>
<tr>
<td> Reserved
</td>
<td> Per-vector masking
</td>
<td> 64-bit
</td>
<td> Multiple Message Enable
</td>
<td> Multiple Message Capable
</td>
<td> Enable
</td></tr></tbody></table>
<p>The message address/data is architecture specific. On x86(-64), it is as follows:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">uint64_t</span> arch_msi_address<span class="br0">(</span><span class="kw4">uint64_t</span> <span class="sy0">*</span>data<span class="sy0">,</span> <span class="kw4">size_t</span> vector<span class="sy0">,</span> <span class="kw4">uint32_t</span> processor<span class="sy0">,</span> <span class="kw4">uint8_t</span> edgetrigger<span class="sy0">,</span> <span class="kw4">uint8_t</span> deassert<span class="br0">)</span> <span class="br0">{</span>
	<span class="sy0">*</span>data <span class="sy0">=</span> <span class="br0">(</span>vector <span class="sy0">&amp;</span> <span class="nu12">0xFF</span><span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span>edgetrigger <span class="sy0">==</span> <span class="nu0">1</span> <span class="sy0">?</span> <span class="nu0">0</span> <span class="sy0">:</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">15</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span>deassert <span class="sy0">==</span> <span class="nu0">1</span> <span class="sy0">?</span> <span class="nu0">0</span> <span class="sy0">:</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">14</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
	<span class="kw1">return</span> <span class="br0">(</span><span class="nu12">0xFEE00000</span> <span class="sy0">|</span> <span class="br0">(</span>processor <span class="sy0">&lt;&lt;</span> <span class="nu0">12</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>MSI interrupts seem to be invariably edge triggered high.
</p><p><b>Multiple messages:</b>
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> MME / MMI </th>
<th> Interrupts
</th></tr>
<tr>
<td> 000 </td>
<td> 1
</td></tr>
<tr>
<td> 001 </td>
<td> 2
</td></tr>
<tr>
<td> 010 </td>
<td> 4
</td></tr>
<tr>
<td> 011 </td>
<td> 8
</td></tr>
<tr>
<td> 100 </td>
<td> 16
</td></tr>
<tr>
<td> 101 </td>
<td> 32
</td></tr></tbody></table>
<p>In MME, specifies the number of low bits of Message Data that may be modified by the device.
</p><p>Therefore, the interrupt vector block allocated must be aligned accordingly.
</p><p><b>Interrupt masking</b>
</p><p>If capable, you can mask individual messages by setting the corresponding bit (1 &lt;&lt; n), in the mask register.
</p><p>If a message is pending, then the corresponding bit in the pending register is set.
</p><p>Note that the PCI specification doesn't specify the location of 
these registers if the message address is 32-bit. This is because a 
function that supports masking is required to implement 64-bit 
addressing!
</p>
<h3> <span class="mw-headline" id="Enabling_MSI-X"> Enabling MSI-X </span></h3>
<p>Like for MSI, you have to find the MSI-X capability, but the ID for MSI-X is <b>0x11</b>
</p><p>The structure is as follows:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Register </th>
<th> Offset </th>
<th> Bits 31-24 </th>
<th> Bits 23-16 </th>
<th> Bits 15-8 </th>
<th> Bits 7-3 </th>
<th> Bits 2-0
</th></tr>
<tr>
<td> Cap + 0x0
</td>
<td> Cap + 0x0
</td>
<td colspan="2"> Message Control
</td>
<td> Next Pointer
</td>
<td colspan="2"> Capability ID = 11
</td></tr>
<tr>
<td> Cap + 0x1
</td>
<td> Cap + 0x4
</td>
<td colspan="4"> Table Offset
</td>
<td colspan="1"> BIR
</td></tr>
<tr>
<td> Cap + 0x2
</td>
<td> Cap + 0x8
</td>
<td colspan="4"> Pending Bit Offset
</td>
<td colspan="1"> Pending Bit BIR
</td></tr></tbody></table>
<p>Unlike MSI, MSI-X supports 2048 interrupts. This is achieved by 
maintaining a table of interrupts in the PCI device's address space. The
 wording of the PCI 3.0 specification indicates that this <i>must</i> be via a Memory BAR.
</p><p><b>BIR</b> specifies which BAR is used for the Message Table. This may be a 64-bit BAR, and is zero-indexed (so BIR=0, BAR0, offset <code>0x10</code> into the header).
</p><p><b>Table Offset</b> is an offset into that BAR where the Message Table lives. Note that it is 8-byte aligned - so simply mask BIR.
</p><p>The format of Message Control is as follows:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bit 15 </th>
<th> Bit 14 </th>
<th> Bits 13-11 </th>
<th> Bits 10-0
</th></tr>
<tr>
<td> Enable
</td>
<td> Function Mask
</td>
<td> Reserved
</td>
<td> Table Size
</td></tr></tbody></table>
<p><b>Table Size</b> is N - 1 encoded, and is the number of entries in the MSI-X table. This field is Read-Only.
</p><p>Now you have all the information you need to find the MSI-X table:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bits 127-96 </th>
<th> Bits 95-64 </th>
<th> Bits 63-32 </th>
<th> Bits 31-0
</th></tr>
<tr>
<td> Vector Control (0)
</td>
<td> Message Data (0)
</td>
<td> Message Address High (0)
</td>
<td> Message Address Low (0)
</td></tr>
<tr>
<td> Vector Control (1)
</td>
<td> Message Data (1)
</td>
<td> Message Address High (1)
</td>
<td> Message Address Low (1)
</td></tr>
<tr>
<td> ...
</td>
<td> ...
</td>
<td> ...
</td>
<td> ...
</td></tr>
<tr>
<td> Vector Control (N - 1)
</td>
<td> Message Data (N - 1)
</td>
<td> Message Address High (N - 1)
</td>
<td> Message Address Low (N - 1)
</td></tr></tbody></table>
<p><b>Vector Control</b> is as follows:
</p>
<table style="margin-top: 1em; margin-bottom: 1em; background: rgb(249, 249, 249) none repeat scroll 0% 0%; border: 1px solid rgb(170, 170, 170); border-collapse: collapse; --darkreader-inline-bgcolor: #1b1e1f; --darkreader-inline-bgimage: none; --darkreader-inline-border-top: #484e51; --darkreader-inline-border-right: #484e51; --darkreader-inline-border-bottom: #484e51; --darkreader-inline-border-left: #484e51;" data-darkreader-inline-bgcolor="" data-darkreader-inline-bgimage="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" cellspacing="0" cellpadding="4" border="2">

<tbody><tr>
<th> Bits 31-1 </th>
<th> Bit 0
</th></tr>
<tr>
<td> Reserved
</td>
<td> Masked
</td></tr></tbody></table>
<p>Note that <b>Message Address</b> is is 4-byte aligned, so, again, mask the low bits. The interrupt is masked if <b>Masked</b> is set to 1.
</p><p>Message Address and Data are as they were for MSI - architecture 
specific. However, unlike with MSI, you can specify independent vectors 
for all the interrupts, only limited by having the same upper 32-bit 
message address.
</p>
<h2> <span class="mw-headline" id="Multi-function_Devices"> Multi-function Devices </span></h2>
<p>Multi-function devices behave in the same manner as normal PCI 
devices. The easiest way to detect a multi-function device is bit 7 of 
the header type field. If it is set (value = <code>0x80</code>), the 
device is multi-function -- else it is not. Make sure you mask this bit 
when you determine header type. To detect the number of functions you 
need to scan the PCI configuration space for every function - unused 
functions have vendor <code>0xFFFF</code>. Device IDs and Class codes vary between functions. Functions are not necessarily in order - you can have function <code>0x0</code>, <code>0x1</code> and <code>0x7</code> in use.
</p>
<h2> <span class="mw-headline" id="Disclaimer"> Disclaimer </span></h2>
<p>This text originates from "Pentium on VME", unknown author, md5sum 
d292807a3c56881c6faba7a1ecfd4c79. The original document is apparently no
 longer present on the Web ...
</p><p>Closest match: <a rel="nofollow" class="external autonumber" href="https://web.archive.org/web/20071009221818/http://www.quicklogic.com/images/appnote10.pdf">[2]</a>
</p>
<h2> <span class="mw-headline" id="References"> References </span></h2>
<ul><li> PCI Local Bus Specification, revision 3.0, PCI Special Interest Group, August 12, 2002
</li></ul>
<h2> <span class="mw-headline" id="See_Also"> See Also </span></h2>
<h3> <span class="mw-headline" id="Articles"> Articles </span></h3>
<ul><li> <a href="https://wiki.osdev.org/PCI_Express" title="PCI Express">PCI Express</a>
</li></ul>
<h3> <span class="mw-headline" id="External_Links"> External Links </span></h3>
<ul><li> <a rel="nofollow" class="external text" href="https://devicehunt.com/about">Very useful page about VendorID and DeviceID</a>
</li><li> <a rel="nofollow" class="external text" href="https://cds.cern.ch/record/551427/files/cer-2308933.pdf">Very detailed PCI-to-PCI architecture specification</a>
</li><li> <a rel="nofollow" class="external text" href="http://xillybus.com/tutorials/pci-express-tlp-pcie-primer-tutorial-guide-1">How PCI Express devices talk</a>
</li><li> <a rel="nofollow" class="external text" href="https://docs.oracle.com/cd/E19120-01/open.solaris/819-3196/hwovr-22/index.html">PCI Local Bus (Solaris documentation)</a>
</li><li> <a rel="nofollow" class="external text" href="https://tldp.org/LDP/tlk/dd/pci.html">PCI in the Linux kernel</a>
</li><li> <a rel="nofollow" class="external text" href="https://pci-ids.ucw.cz/">More up to date PCI vendor and device numbers</a>
</li><li> <a rel="nofollow" class="external text" href="https://msdn.microsoft.com/en-us/library/ms903537.aspx">Structure describes that PCI configuration space for PCI devices</a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 321/1000000
Post-expand include size: 3240/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1485-0!*!0!!en!*!* and timestamp 20220110060240 -->
</div>				<!-- /bodycontent -->
								<!-- printfooter -->
				<div class="printfooter">
				Retrieved from "<a href="https://wiki.osdev.org/index.php?title=PCI&amp;oldid=26754">https://wiki.osdev.org/index.php?title=PCI&amp;oldid=26754</a>"				</div>
				<!-- /printfooter -->
												<!-- catlinks -->
				<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks"><a href="https://wiki.osdev.org/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="https://wiki.osdev.org/Category:Buses" title="Category:Buses">Buses</a></li><li><a href="https://wiki.osdev.org/index.php?title=Category:PCI&amp;action=edit&amp;redlink=1" class="new" title="Category:PCI (page does not exist)">PCI</a></li></ul></div></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
				<!-- debughtml -->
								<!-- /debughtml -->
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Personal tools</h5>
	<ul>
		<li id="pt-login"><a href="https://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=PCI" title="You are encouraged to log in; however, it is not mandatory [alt-shift-o]" accesskey="o">Log in</a></li>
	</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li id="ca-nstab-main" class="selected"><span><a href="https://wiki.osdev.org/PCI" title="View the content page [alt-shift-c]" accesskey="c">Page</a></span></li>
					<li id="ca-talk"><span><a href="https://wiki.osdev.org/Talk:PCI" title="Discussion about the content page [alt-shift-t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Variants</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="https://wiki.osdev.org/PCI">Read</a></span></li>
					<li id="ca-viewsource"><span><a href="https://wiki.osdev.org/index.php?title=PCI&amp;action=edit" title="This page is protected.
You can view its source [alt-shift-e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="https://wiki.osdev.org/index.php?title=PCI&amp;action=history" title="Past revisions of this page [alt-shift-h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="/index.php" id="searchform">
		<input type="hidden" name="title" value="Special:Search">
				<input type="search" name="search" title="Search OSDev Wiki [alt-shift-f]" accesskey="f" id="searchInput">		<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton">		<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton">			</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(/skins/common/images/osdev.png);" href="https://wiki.osdev.org/Main_Page" title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id="p-navigation">
	<h5>Navigation</h5>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="https://wiki.osdev.org/Main_Page" title="Visit the main page [alt-shift-z]" accesskey="z">Main Page</a></li>
			<li id="n-portal"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things">Forums</a></li>
			<li id="n-FAQ"><a href="https://wiki.osdev.org/Category:FAQ">FAQ</a></li>
			<li id="n-OS-Projects"><a href="https://wiki.osdev.org/Projects">OS Projects</a></li>
			<li id="n-randompage"><a href="https://wiki.osdev.org/Special:Random" title="Load a random page [alt-shift-x]" accesskey="x">Random page</a></li>
		</ul>
	</div>
</div>

<!-- /navigation -->

<!-- about -->
<div class="portal" id="p-about">
	<h5>About</h5>
	<div class="body">
		<ul>
			<li id="n-This-site"><a href="https://wiki.osdev.org/OSDevWiki:About">This site</a></li>
			<li id="n-Joining"><a href="https://wiki.osdev.org/OSDevWiki:Joining">Joining</a></li>
			<li id="n-Editing-help"><a href="https://wiki.osdev.org/OSDevWiki:Editing">Editing help</a></li>
			<li id="n-recentchanges"><a href="https://wiki.osdev.org/Special:RecentChanges" title="A list of recent changes in the wiki [alt-shift-r]" accesskey="r">Recent changes</a></li>
		</ul>
	</div>
</div>

<!-- /about -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id="p-tb">
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="https://wiki.osdev.org/Special:WhatLinksHere/PCI" title="A list of all wiki pages that link here [alt-shift-j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="https://wiki.osdev.org/Special:RecentChangesLinked/PCI" title="Recent changes in pages linked from this page [alt-shift-k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="https://wiki.osdev.org/Special:SpecialPages" title="A list of all special pages [alt-shift-q]" accesskey="q">Special pages</a></li>
			<li><a href="https://wiki.osdev.org/index.php?title=PCI&amp;printable=yes" rel="alternate">Printable version</a></li>
			<li id="t-permalink"><a href="https://wiki.osdev.org/index.php?title=PCI&amp;oldid=26754" title="Permanent link to this revision of the page">Permanent link</a></li>
		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->
<div class="portal" id="p-lang">
	<h5>In other languages</h5>
	<div class="body">
		<ul>
			<li class="interwiki-de"><a href="http://www.lowlevel.eu/wiki/Peripheral_Component_Interconnect" title="Peripheral Component Interconnect">Deutsch</a></li>
		</ul>
	</div>
</div>

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 17 December 2021, at 13:49.</li>
											<li id="footer-info-viewcount">This page has been accessed 530,361 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="https://wiki.osdev.org/OSDev_Wiki:Privacy_policy" title="OSDev Wiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="https://wiki.osdev.org/OSDev_Wiki:About" title="OSDev Wiki:About">About OSDev Wiki</a></li>
											<li id="footer-places-disclaimer"><a href="https://wiki.osdev.org/OSDev_Wiki:General_disclaimer" title="OSDev Wiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="PCI%20-%20OSDev%20Wiki_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31"></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<!-- fixalpha -->
		<script type="text/javascript"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		<script src="PCI%20-%20OSDev%20Wiki_files/load_003.php"></script>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script><script type="text/javascript" src="PCI%20-%20OSDev%20Wiki_files/load_005.php"></script>
<script src="PCI%20-%20OSDev%20Wiki_files/load_002.php"></script>
<script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,
	"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: wikidb:resourceloader:filter:minify-js:4:19a4b18a9ac79a6b8c60b24af4668814 */
}
</script><!-- Served in 0.189 secs. -->
	

</body></html>